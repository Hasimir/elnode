= Elnode =

An attempt to make an EmacsLISP clone of node.js.


== Installation ==

Elnode is now packaged in [[http://marmalade-repo.org/packages/elnode|marmalade]]. 

For dealing with package repositories check out the
[[http://www.emacswiki.org/emacs/ELPA|Emacs Wiki]] but the short version
is to add the following to your {{{.emacs}}} or your
{{{.emacs.d/init.el}}}:

{{{
(add-to-list 
   'package-archives
   '("marmalade" . "http://marmalade-repo.org/packages/"))
}}}

If you don't want to use packages you can just install {{{elnode.el}}}
on your {{{load-path}}} somewhere and:

{{{
(require 'elnode)
}}}

== Out of the box ==

When Elnode initializes it automatically starts a webserver.

If you:

{{{
M-x customize-group
elnode
}}}

you can alter a number of variables pertaining to the default configuration.

You can also just ignore it and write your own servers.


== How does it work? ==

You can define a handler function:

{{{
(defun nicferrier-handler (httpcon)
  "Demonstration function"
  (elnode-http-start httpcon "200" '("Content-type" . "text/html"))
  (elnode-http-return httpcon "<html><b>HELLO!</b></html>")
  )
}}}

And then start the server:

{{{
(elnode-start 'nicferrier-handler 8010 "localhost")
}}}

You can also start the server interactively... you still have to pass
it a handler function and a port.

=== Stopping the server ===

If you can remember the port you started your server on then you'll be
able to stop it, like:

{{{
(elnode-stop 8010)
}}}

You can also stop interactively:

{{{
M-x elnode-stop
}}}



== API ==

=== elnode-child-process (HTTPCON PROGRAM &REST ARGS) ===

Run the specified process asynchronously and send it's output to the http connection.

program is the program to run.
args is a list of arguments to pass to the program.

It is NOT POSSIBLE to run more than one process at a time
directed at the same http connection.


=== elnode-defer-now (HANDLER) ===

The function you call to defer processing of the current socket.

Pass in the current HANDLER.

FIXME: We could capture the current handler somehow? I think the
point is that whatever signals elnode-defer should be getting
control back when the deferred is re-processed.


=== elnode-defer-or-do (GUARD &REST BODY) ===

Test the GUARD and defer if it suceeds and BODY if it doesn't.


=== elnode-dispatcher (HTTPCON URL-MAPPING-TABLE &OPTIONAL FUNCTION-404) ===

Dispatch the HTTPCON to the correct function based on the URL-MAPPING-TABLE.

URL-MAPPING-TABLE is an alist of:

{{{
 (url-regex . function-to-dispatch)
}}}

To map the root url you should use:

{{{
  $
}}}

[[elnode-dispatcher]] uses [[elnode-normalize-path]] to ensure paths
end in / so to map another url you should use:

{{{
  path/$
}}}

or:

{{{
  path/subpath/$
}}}



=== elnode-error (MSG &REST ARGS) ===

Log MSG with ARGS as an error.

This function is available for handlers to call.  It is also used
by elnode iteslf.

There is only one error log, in the future there may be more.


=== elnode-hostpath-default-handler (HTTPCON) ===

A hostpath handler using the [[elnode-hostpath-default-table]] for the match table.

This simply calls [[elnode-hostpath-dispatcher]] with [[elnode-hostpath-default-table]].


=== elnode-hostpath-dispatcher (HTTPCON HOSTPATH-MAPPING-TABLE &OPTIONAL FUNCTION-404) ===

Dispatch the HTTPCON to the correct handler based on the HOSTPATH-MAPPING-TABLE.

HOSTPATH-MAPPING-TABLE has a regex of the host and the path slash separated, thus:

{{{
 ("^localhost/pastebin.*" . pastebin-handler)
}}}



=== elnode-http-cookie (HTTPCON NAME) ===

Get the cookie value specified by the name.


=== elnode-http-header (HTTPCON NAME) ===

Get the header specified by name from the header.


=== elnode-http-method (HTTPCON) ===

Get the PATHINFO of the request.


=== elnode-http-param (HTTPCON NAME) ===

Get the named parameter from the request.


=== elnode-http-params (HTTPCON) ===

Get an alist of the parameters in the request.

If the method is a GET then the parameters are from the url. If
the method is a POST then the parameters may come from either the
url or the POST body or both:

{{{
 POST /path?a=b&x=y
 a=c
}}}

would result in:

{{{
 '(([[a]] [[b]] [[c]])([[x]] . [[y]]))
}}}



=== elnode-http-pathinfo (HTTPCON) ===

Get the PATHINFO of the request.


=== elnode-http-query (HTTPCON) ===

Get the QUERY of the request.


=== elnode-http-return (HTTPCON &OPTIONAL DATA) ===

End the response on HTTPCON optionally sending DATA first.

HTTPCON is the http connection which must have had the headers
sent with [[elnode-http-start]]

DATA must be a string, it's just passed to [[elnode-http-send]].


=== elnode-http-send-string (HTTPCON STR) ===

Send the string to the HTTP connection.

This is really only a placeholder function for doing transfer-encoding.


=== elnode-http-start (HTTPCON STATUS &REST HEADER) ===

Start the http response on the specified http connection.

httpcon is the HTTP connection being handled.
status is the HTTP status, eg: 200 or 404
header is a sequence of (header-name . value) pairs.

For example:

{{{
 (elnode-http-start httpcon "200" '("Content-type" . "text/html"))
}}}



=== elnode-http-version (HTTPCON) ===

Get the PATHINFO of the request.


=== elnode-init NIL ===

Bootstraps the elnode environment when the Lisp is loaded.

It's useful to have elnode start automatically... on Lisp
load.  If the variable [[elnode-init-port]] is set then this
function will launch a server on it.

The server is started with [[elnode-hostpath-default-handler]] as
the handler and listening on [[elnode-init-host]]


=== elnode-list-buffers NIL ===

List the current buffers being managed by elnode.


=== elnode-normalize-path (HTTPCON HANDLER) ===

A decorator for HANDLER that normalizes paths to have a trailing slash.

This checks the HTTPCON path for a trailing slash and sends a 302
to the slash trailed url if there is none.

Otherwise it calls HANDLER.


=== elnode-send-400 (HTTPCON) ===

A generic 400 handler.


=== elnode-send-404 (HTTPCON) ===

A generic 404 handler.


=== elnode-send-redirect (HTTPCON LOCATION) ===

Sends a redirect to the specified location.


=== elnode-start (REQUEST-HANDLER PORT HOST) ===

Start the elnode server so that REQUEST-HANDLER handles requests on PORT on HOST.

Most of the work done by the server is actually done by
functions, the sentinel function, the log function and a filter
function.

request-handler is a function which is called with the
request. The function is called with one argument, the
http-connection.

You can use functions such as elnode-http-start and
elnode-http-send-body to send the http response.

Example:

{{{
 (defun nic-server (httpcon)
   (elnode-http-start 200 '(("Content-Type": "text/html")))
   (elnode-http-return "<html><b>BIG!</b></html>")
   )
 (elnode-start 'nic-server 8000)
 ;; End
}}}

You must also specify the port to start the server on.

You can optionally specify the hostname to start the server on,
this must be bound to a local IP. Some names are special:

{{{
  localhost  means 127.0.0.1
  * means 0.0.0.0
}}}

specifying an IP is also possible.

Note that although host can be specified, elnode does not
disambiguate on running servers by host. So you cannot start 2
different elnode servers on the same port on different hosts.


=== elnode-stop (PORT) ===

Stop the elnode server attached to PORT.


=== elnode-test-path (HTTPCON DOCROOT HANDLER &OPTIONAL 404-HANDLER) ===

Check that the path requested is above the docroot specified.

Call 404-handler (or default 404 handler) on failure and handler
on success.

handler is called: httpcon docroot targetfile

This is used by [[elnode--webserver-handler-proc]] in the webservers
that it creates... but it's also meant to be generally useful for
other handler writers.


=== elnode-webserver (HTTPCON) ===

A simple webserver that serves documents out of `elnode-webserver-docroot'.

This is just an example of an elnode webserver, but it may be all
that is needed most of the time.

See [[elnode-webserver-handler-maker]] for more possibilities for
making webserver functions.

HTTPCON is the HTTP connection to the user agent.


=== elnode-webserver-handler-maker (&OPTIONAL DOCROOT EXTRA-MIME-TYPES) ===

Make a webserver handler possibly with the DOCROOT and EXTRA-MIME-TYPES.

Returns a proc which is the handler. The handler serves files out
of the docroot and marks them with the content types that Emacs
knows about. You can add extra content types for the webserver
just by supplying an alist of mime-types and extensions for
EXTRA-MIME-TYPES.

The webserver handler also creates file indexes.

The webserver uses [[elnode-test-path]] to make sure that the
request does not go above the DOCROOT.




== But... ==

There's always a but.

Here's a list of buts:

 * the HTTP parsing isn't great, it uses too many regexs
 * we don't parse any data sent through POST other than form-data
 * the error handling is absolute rubbish

== To Do? ==

If you're playing with elnode but you can't think of anything to do with it...

 * an elpa repository written with elnode
 ** turn the package list into html
 ** allow packages to be downloaded from elnode
 ** upload of packages will require fixing the request management a little
 * an emacsclient with elnode
 ** write a command line client that submits data to the server over HTTP
 ** it should interact with the emacs user in the same way that emacs server does
 * a simple wiki engine with elnode
 ** maybe using a command line wiki templating tool
 * alter {{{elnode-webserver-handler-maker}}} to do indexing better
 ** take an optional index producing function?
 ** take keyword flags that set the behaviour? 
 ** eg: {{{:doindexes 't }}}