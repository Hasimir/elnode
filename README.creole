= Elnode =

An evented IO webserver in Emacs Lisp.


== Requirements ==

Elnode will not run properly on anything less than Emacs 24.  Elnode
requires Emacs 24's lexical binding as it makes extensive use of
closures.


== Rationale ==

Elnode is a great for these things:

 * nice simple server with few dependancies (just Emacs and {{{cat}}} basically)
 * prototyping webapps
 * browser testing
 * asynchronous apps, like chat apps


== Installation ==

Elnode is packaged in [[http://marmalade-repo.org/packages/elnode|marmalade]]. 

For dealing with package repositories check out the
[[http://www.emacswiki.org/emacs/ELPA|Emacs Wiki]] but the short version
is to add the following to your {{{.emacs}}} or your
{{{.emacs.d/init.el}}}:

{{{
(add-to-list 
   'package-archives
   '("marmalade" . "http://marmalade-repo.org/packages/"))
}}}

And then do:

{{{
M-x list-packages
}}}

find Elnode in the list and press {{{i}}} or {{{ENTER}}} to install it.

If you don't want to use packages you can just install {{{elnode.el}}}
on your {{{load-path}}} somewhere and:

{{{
(require 'elnode)
}}}

=== Install from this repository ===

You can make a package locally, with this repository:

{{{
M-x compile [RET] make clean all [RET]
}}}

And then you can install that package:

{{{
M-x package-install-file [RET] elnode-0.9.9.tar [RET]
}}}

You can also use the other Makefile targets, such as {{{test}}}.

Unless you are developing Elnode I advise that you use the packaged
version.

== Out of the box ==

When Elnode initializes it automatically starts a webserver and a Wiki
engine.

If you:

{{{
M-x customize-group
elnode
}}}

you can alter a number of variables pertaining to the default
configuration, including the directory used to keep files.

By default the package installs files in your {{{.emacs.d}}} - it uses
a directory called {{{elnode}}} for the Wiki root and the
webroot. Both are configurable with Elnode config variables.

You can also just ignore the built in stuff completely and write your
own servers.


== How does it work? ==

You can define a handler function:

{{{
(defun nicferrier-handler (httpcon)
  "Demonstration function"
  (elnode-http-start httpcon 200 '("Content-type" . "text/html"))
  (elnode-http-return httpcon "<html><b>HELLO!</b></html>"))
}}}

And then start the server:

{{{
(elnode-start 'nicferrier-handler :port 8010 :host "localhost")
}}}

You can also start the server interactively... with:

{{{
M-x elnode-start
}}}

it interactively asks for the handler function and a port.

=== Stopping the server ===

If you can remember the port you started your server on then you'll be
able to stop it, like:

{{{
(elnode-stop 8010)
}}}

You can also stop interactively:

{{{
M-x elnode-stop
}}}



== API ==

=== Mapping paths to handlers ===

{{{elnode-hostpath-dispatcher}}} takes a-list of path/handler mappings:

{{{
##!emacs-lisp
(defvar 
   my-app-routes 
   '(("^my-host.example.com//wiki/\\(.*\\)" . elnode-wikiserver)
     ("^admin.example.com//admintool/\\(.*\\)" . user-admin)
     ("^.*//\\(.*\\)" . elnode-webserver)))

(defun root-handler (httpcon)
  (elnode-hostpath-dispatcher httpcon my-app-routes))

(elnode-start 'root-handler :port 8009)
}}}

This will create a server on port 8009 being handled by
{{{root-handler}}} which will root the requests to the appropriate handler.

Any request for the host {{{my-host.example.com}}} with the path
{{{/wiki/}}} will be sent to the Elnode Wiki engine.

Any request for the host {{{admin.example.com}}} with the path
{{{/admintool/}}} will be sent to the {{{user-admin}}} handler,
presumably that is defined somewhere.

Any other request will be sent to the default Elnode webserver.

Elnode itself uses a hostpath dispatcher on the default Elnode server.
This can actually be configured with the variable
{{{elnode-hostpath-default-table}}}, so you can actually change the
default behaviour of the Elnode default server just with Emacs config.


The use of regexs in Elnode's mapping is supported by other
tools. Sub-expressions are capturable in mapping support routines such
as {{{elnode-docroot-for}}}.

When a handler is called by {{{elnode-hostpath-dispatcher}}} then the
parts of the match are available through the function
{{{elnode-http-mapping}}}. So we could code the {{{user-admin}}} handler like this:

{{{
##! emacs-lisp
(defun user-admin (httpcon)
  (let ((username (elnode-http-mapping httpcon 1)))
    (user-admin-send-admin-page httpcon username)))
}}}

The {{{(elnode-http-mapping httpcon 1)}}} accesses the first
sub-expression of the regex that caused the match:

{{{
     ("^admin.example.com//admintool/\\(.*\\)" . user-admin)
}}}

so, everything AFTER the {{{admintool/}}}.

Some tools in Elnode do this for you, so you don't have to. Again,
look at {{{elnode-docroot-for}}}.

=== Accessing data in the HTTP request ===

There are a bunch of functions that do what you would expect about
data in the HTTP request:

{{{
##! emacs-lisp

(elnode-http-pathinfo httpcon)
=> "/wiki/blah.creole"

(elnode-http-param httpcon "username")
=> "nicferrier"

(elnode-http-cookie httpcon "session-id")
=> "1213313"

(elnode-http-header httpcon "Date")
=> "Mon, Feb 27 2012 22:10:21 GMT"

(elnode-http-header httpcon 'date)
=> "Mon, Feb 27 2012 22:10:21 GMT"

(elnode-http-header httpcon 'date :time) ;; with convert flag set to :time
=> (20299 65357)
}}}

Note that Elnode generally can accept symbol's as well as strings to
name things, if it can't it's a bug, 
[[https://github.com/nicferrier/elnode/issues|please report it]].

Also, Elnode can handle some conversions sometimes. I would like to
respond to user demand about when and where to do that and what to
do. Please give me feedback.



== To Do? ==

If you're playing with elnode but you can't think of anything to do with it...

 * an elpa repository written with elnode
 ** turn the package list into html
 ** allow packages to be downloaded from elnode
 ** upload of packages will require fixing the request management a little
 * an emacsclient with elnode
 ** write a command line client that submits data to the server over HTTP
 ** it should interact with the emacs user in the same way that emacs server does
 ** //why?// because then a single Emacs could have just 1 server socket open for all sorts of different roles
 * alter {{{elnode-webserver-handler-maker}}} to do indexing better
 ** take an optional index producing function?
 ** take keyword flags that set the behaviour? 
 ** eg: {{{:doindexes 't }}}
 * browse-current-buffer
 ** start an elnode server on some random port exposing the current buffer
 ** automatically open a browser on the started server
